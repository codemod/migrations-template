name: PR-based Auto-publish

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'recipes/**'
  issue_comment:
    types: [created]

jobs:
  detect-changes:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      codemods: ${{ steps.detect.outputs.codemods }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for diff
    
    - name: Detect codemod changes
      id: detect
      run: |
        # Get the base and head commits
        BASE_SHA="${{ github.event.pull_request.base.sha }}"
        HEAD_SHA="${{ github.event.pull_request.head.sha }}"
        
        echo "Comparing $BASE_SHA..$HEAD_SHA"
        
        # Find changed codemod directories
        CHANGED_CODEMODS=$(git diff --name-only $BASE_SHA..$HEAD_SHA | grep '^recipes/' | cut -d'/' -f1-2 | sort -u | tr '\n' ' ')
        
        if [ -z "$CHANGED_CODEMODS" ]; then
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "No codemod changes detected"
          exit 0
        fi
        
        echo "has-changes=true" >> $GITHUB_OUTPUT
        echo "codemods=$CHANGED_CODEMODS" >> $GITHUB_OUTPUT
        
        echo "Changed codemods: $CHANGED_CODEMODS"
        
        # Generate publish commands for each changed codemod
        PUBLISH_COMMANDS=""
        for codemod_dir in $CHANGED_CODEMODS; do
          if [ -f "$codemod_dir/codemod.yaml" ]; then
            # Extract name and version from codemod.yaml
            NAME=$(grep '^name:' "$codemod_dir/codemod.yaml" | sed 's/name: *//' | tr -d ' ')
            VERSION=$(grep '^version:' "$codemod_dir/codemod.yaml" | sed 's/version: *//' | tr -d ' ')
            
            if [ -n "$NAME" ] && [ -n "$VERSION" ]; then
              COMMAND="git tag -a v${VERSION}@${NAME} -m \"Release version v${VERSION} for ${NAME}\""
              PUBLISH_COMMANDS="${PUBLISH_COMMANDS}${COMMAND}\n"
            fi
          fi
        done
        
        # Store commands for later use
        echo "PUBLISH_COMMANDS<<EOF" >> $GITHUB_ENV
        echo -e "$PUBLISH_COMMANDS" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

  comment-on-pr:
    if: github.event_name == 'pull_request' && needs.detect-changes.outputs.has-changes == 'true'
    needs: detect-changes
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm install
    
    - name: Comment on PR
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          // Check if we already commented
          const existingComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('Show a thumbs up to this comment')
          );
          
          if (existingComment) {
            console.log('Comment already exists, skipping...');
            return;
          }
          
          const codemods = '${{ needs.detect-changes.outputs.codemods }}'.split(' ').filter(Boolean);
          const publishCommands = process.env.PUBLISH_COMMANDS || '';
          
          const commentBody = `## 🚀 Ready to Publish Codemods
          
          **Changed codemods:** ${codemods.map(c => `\`${c}\``).join(', ')}
          
          Show a thumbs up 👍 to this comment and I'll run the below commands to auto-publish the codemod(s) to the registry:
          
          \`\`\`bash
          ${publishCommands}git push origin --tags
          \`\`\`
          
          **Note:** Only reactions from repository maintainers will trigger the publishing workflow.
          
          ---
          *This comment was automatically generated by the PR-based auto-publish workflow.*`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: commentBody
          });

  handle-reaction:
    if: github.event_name == 'issue_comment'
    runs-on: ubuntu-latest
    
    steps:
    - name: Check if comment is from our bot
      id: check-comment
      run: |
        COMMENT_BODY="${{ github.event.comment.body }}"
        if echo "$COMMENT_BODY" | grep -q "Show a thumbs up to this comment"; then
          echo "is-bot-comment=true" >> $GITHUB_OUTPUT
        else
          echo "is-bot-comment=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Check for thumbs up reaction
      if: steps.check-comment.outputs.is-bot-comment == 'true'
      id: check-reaction
      uses: actions/github-script@v7
      with:
        script: |
          const { data: reactions } = await github.rest.reactions.listForIssueComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.event.comment.id,
          });
          
          // Get repository collaborators to check if reactor is a maintainer
          const { data: collaborators } = await github.rest.repos.listCollaborators({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          
          const maintainers = collaborators
            .filter(collab => collab.permissions.admin || collab.permissions.maintain)
            .map(collab => collab.login);
          
          const thumbsUpReaction = reactions.find(reaction => 
            reaction.content === '+1' && maintainers.includes(reaction.user.login)
          );
          
          if (thumbsUpReaction) {
            console.log('Maintainer approved with thumbs up!');
            core.setOutput('approved', 'true');
            core.setOutput('approver', thumbsUpReaction.user.login);
          } else {
            console.log('No maintainer approval found');
            core.setOutput('approved', 'false');
          }
    
    - name: Checkout code
      if: steps.check-reaction.outputs.approved == 'true'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Node.js
      if: steps.check-reaction.outputs.approved == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
    
    - name: Install dependencies
      if: steps.check-reaction.outputs.approved == 'true'
      run: npm install
    
    - name: Extract and execute publish commands
      if: steps.check-reaction.outputs.approved == 'true'
      run: |
        COMMENT_BODY="${{ github.event.comment.body }}"
        
        # Extract commands from the comment
        echo "Extracting commands from comment..."
        
        # Get the bash code block content
        COMMANDS=$(echo "$COMMENT_BODY" | sed -n '/```bash/,/```/p' | sed '1d;$d')
        
        echo "Executing commands:"
        echo "$COMMANDS"
        
        # Execute the commands
        echo "$COMMANDS" | bash
        
        echo "✅ Publishing commands executed successfully!"
    
    - name: Update comment with success
      if: steps.check-reaction.outputs.approved == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const approver = '${{ steps.check-reaction.outputs.approver }}';
          const commentBody = `## ✅ Published Successfully!
          
          **Approved by:** @${approver}
          **Published at:** ${new Date().toISOString()}
          
          The codemods have been successfully published to the registry.
          
          ---
          *This comment was automatically updated by the PR-based auto-publish workflow.*`;
          
          await github.rest.issues.updateComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.event.comment.id,
            body: commentBody
          });
